"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const architect_1 = require("@angular-devkit/architect");
const fs_1 = require("fs");
const path_1 = require("path");
const create_directory_1 = require("./utils/create-directory");
const eslint_utils_1 = require("./utils/eslint-utils");
exports.default = (0, architect_1.createBuilder)(async (options, context) => {
    var _a, _b, _c;
    const workspaceRoot = context.workspaceRoot;
    process.chdir(workspaceRoot);
    const projectName = ((_a = context.target) === null || _a === void 0 ? void 0 : _a.project) || '<???>';
    const printInfo = options.format && !options.silent;
    const reportOnlyErrors = options.quiet;
    const maxWarnings = options.maxWarnings;
    if (printInfo) {
        console.info(`\nLinting ${JSON.stringify(projectName)}...`);
    }
    const projectESLint = await (0, eslint_utils_1.loadESLint)();
    const version = (_c = (_b = projectESLint.ESLint) === null || _b === void 0 ? void 0 : _b.version) === null || _c === void 0 ? void 0 : _c.split('.');
    if (!version ||
        version.length < 2 ||
        Number(version[0]) < 7 ||
        (Number(version[0]) === 7 && Number(version[1]) < 6)) {
        throw new Error('ESLint must be version 7.6 or higher.');
    }
    const eslint = new projectESLint.ESLint({});
    /**
     * We want users to have the option of not specifying the config path, and let
     * eslint automatically resolve the `.eslintrc` files in each folder.
     */
    const eslintConfigPath = options.eslintConfig
        ? (0, path_1.resolve)(workspaceRoot, options.eslintConfig)
        : undefined;
    let lintResults = [];
    try {
        lintResults = await (0, eslint_utils_1.lint)(workspaceRoot, eslintConfigPath, options);
    }
    catch (err) {
        if (err instanceof Error &&
            err.message.includes('You must therefore provide a value for the "parserOptions.project" property for @typescript-eslint/parser')) {
            let eslintConfigPathForError = `for ${projectName}`;
            const projectMetadata = await context.getProjectMetadata(projectName);
            if (projectMetadata) {
                eslintConfigPathForError = `\`${projectMetadata.root}/.eslintrc.json\``;
            }
            console.error(`
    Error: You have attempted to use a lint rule which requires the full TypeScript type-checker to be available, but you do not have \`parserOptions.project\` configured to point at your project tsconfig.json files in the relevant TypeScript file "overrides" block of your ESLint config ${eslintConfigPath || eslintConfigPathForError}
    
    For full guidance on how to resolve this issue, please see https://github.com/angular-eslint/angular-eslint/blob/main/docs/RULES_REQUIRING_TYPE_INFORMATION.md
    `);
            return {
                success: false,
            };
        }
        // If some unexpected error, rethrow
        throw err;
    }
    if (lintResults.length === 0) {
        throw new Error('Invalid lint configuration. Nothing to lint.');
    }
    const formatter = await eslint.loadFormatter(options.format);
    let totalErrors = 0;
    let totalWarnings = 0;
    // output fixes to disk, if applicable based on the options
    await projectESLint.ESLint.outputFixes(lintResults);
    /**
     * Depending on user configuration we may not want to report on all the
     * results, so we need to adjust them before formatting.
     */
    const finalLintResults = lintResults
        .map((result) => {
        totalErrors += result.errorCount;
        totalWarnings += result.warningCount;
        if (result.errorCount || (result.warningCount && !reportOnlyErrors)) {
            if (reportOnlyErrors) {
                // Collect only errors (Linter.Severity === 2)
                result.messages = result.messages.filter(({ severity }) => severity === 2);
            }
            return result;
        }
        return null;
    })
        // Filter out the null values
        .filter(Boolean);
    const hasWarningsToPrint = totalWarnings > 0 && !reportOnlyErrors;
    const hasErrorsToPrint = totalErrors > 0;
    /**
     * It's important that we format all results together so that custom
     * formatters, such as checkstyle, can provide a valid output for the
     * whole project being linted.
     *
     * Additionally, apart from when outputting to a file, we want to always
     * log (even when no results) because different formatters handled the
     * "no results" case differently.
     */
    const formattedResults = await formatter.format(finalLintResults);
    if (options.outputFile) {
        const pathToOutputFile = (0, path_1.join)(context.workspaceRoot, options.outputFile);
        (0, create_directory_1.createDirectory)((0, path_1.dirname)(pathToOutputFile));
        (0, fs_1.writeFileSync)(pathToOutputFile, formattedResults);
    }
    else {
        console.info(formattedResults);
    }
    if (hasWarningsToPrint && printInfo) {
        console.warn('Lint warnings found in the listed files.\n');
    }
    if (hasErrorsToPrint && printInfo) {
        console.error('Lint errors found in the listed files.\n');
    }
    if ((totalWarnings === 0 || reportOnlyErrors) &&
        totalErrors === 0 &&
        printInfo) {
        console.info('All files pass linting.\n');
    }
    const tooManyWarnings = maxWarnings >= 0 && totalWarnings > maxWarnings;
    if (tooManyWarnings && printInfo) {
        console.error(`Found ${totalWarnings} warnings, which exceeds your configured limit (${options.maxWarnings}). Either increase your maxWarnings limit or fix some of the lint warnings.`);
    }
    return {
        success: options.force || (totalErrors === 0 && !tooManyWarnings),
    };
});
